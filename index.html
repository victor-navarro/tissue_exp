<!doctype html>
<html>
<head>
    <title>UIOWA Comparative Cognition Lab</title>
    <script src="./js/jquery.min.js"></script>
    <script src="./js/jspsych.js"></script>
    <script src="./js/seedrandom.min.js"></script>
    <script src="./js/plugins/snap.svg-min.js"></script>
    <script src="./js/plugins/jspsych-text.js"></script>
    <script src="./js/plugins/jspsych-survey-text.js"></script>
    <script src="./js/plugins/jspsych-html-button-response.js"></script>
	<script src="./js/plugins/jspsych-html-keyboard-response.js"></script>
	<script src="./js/plugins/jspsych-image-keyboard-response.js"></script>
    <script src="./js/plugins/jspsych-survey-multi-choice.js"></script>
    <script src="./js/plugins/jspsych-instructions.js"></script>
    <script src="./js/welcome.js"></script>
	<script src="./set_info/base_sets.js"></script>
    <link href="./js/css/jspsych.css" rel="stylesheet" type="text/css"></link>
</head>
<body>
    <div id="welcome"></div>
</body>
<script>


/*
var check = '<p>computer</p>';
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|net0[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = '<p>mobile</p>';})(navigator.userAgent||navigator.vendor||window.opera);
console.log(check)
*/


//simple function to create an array like 8:10
function intRange(lowEnd, highEnd){
	var list = [];
	for (var i = lowEnd; i <= highEnd; i++) {
		list.push(i);
	}
	return list
	}

//function to return trials for a block
function getBlock(set, bsize){
	bsize = bsize/2; //giving an equal number of trials per category
	//takes advantage of the set being sorted into two categories
	setsize = set.length;
	//sample from first category
	catA = jsPsych.randomization.shuffle(intRange(0, (setsize/2)-1));
	catB = jsPsych.randomization.shuffle(intRange((setsize/2), setsize-1));
	//join and randomize
	return jsPsych.randomization.shuffle(catA.slice(0, bsize).concat(catB.slice(0, bsize))) //only works when bsize =< catA.length
	
}

function getBlocksFromArray(sets, bsize){
	bsize = bsize/sets.length;
	sizes = [];
	blocks = [];
	i = 0
	for (s = 0; s < sets.length; s++){
		sizes.push(sets[s].length);
		//get trials form a set, using the getBlock function
		trials = getBlock(sets[s], bsize);
		for (t = 0; t < bsize; t++){
		blocks[i] = [s, trials[t]];
		i++;
		}
	}
	return(jsPsych.randomization.shuffle(blocks))
}


Math.seedrandom();
rSeed = Math.floor(Math.random()*9999999);
Math.seedrandom(rSeed);

//MY VARS//
var image_root = 'images/base/';
//randomize training/testing sets
var sets = ['A', 'B'];
var baseSet = sets[jsPsych.randomization.shuffle([0, 1])[0]];

//randomize category responses
var catKey = jsPsych.randomization.shuffle(['CA', 'NM']);

button_prompt = 'Benign (F) or Malignant (J)?';
if (catKey[0] == 'CA'){
	button_prompt = 'Malignant (F) or Benign (J)?';
	}

function evalChoice(keypress, cat, catKey){
	if (keypress == 70){
		return catKey[0]==cat;
	}else{
		return catKey[1]==cat;
	}
}

//Assign sets of images
var trainSet = A4x00;
var rotSets = [A4xVF, A4xHF, A4x90, A4x27, A4x18];
var novelSet = B4x00;
if (baseSet == 'B'){
	trainSet= B4x00;
	rotSets = [B4xVF, B4xHF, B4x90, B4x27, B4x18];
	novelSet = A4x00;
	}
	
//create an array for preloading images; not nice
preload_arr = [];
for (i = 0; i < trainSet.length; i++){
	preload_arr[i] = image_root+trainSet[i].exemplar;
}
psize = preload_arr.length;
for (i = 0; i < novelSet.length; i++){
	preload_arr[psize+i] = image_root+novelSet[i].exemplar;
}
for (s = 0; s < rotSets.length; s++){
	psize = preload_arr.length;
	for (i = 0; i < rotSets[s].length; i++){
		preload_arr[psize+i] = image_root+rotSets[s][i].exemplar;
	}
}


var turkWorkerID = 0;
// This next bit gets the worker ID, which will be passed in the parameters in the URL
// It uses code from https://www.xul.fr/javascript/parameters.php
if (location.search.substring(1)) {
    var parameters = location.search.substring(1).split("&");
    var temp = parameters[0].split("=");
    if (temp[1]) {turkWorkerID = unescape(temp[1])};
};



//NEEDED//
var turkcode = getTurkCode();
var bonusAmount = 2;
var feedbackDuration = 1000; //in ms
var correctionTrial = false;
var firstAttempt = true;
var trialOutcome;
var totalCorrect = 0;
var totalTrials = 0;
var comparisonDelay = 500;
var numTrialsTotal = 69;
var expPhase = 'Training';
var blockCACorrects = 0; 
var blockNMCorrects = 0;
var blockSize = 4; //How many trials per block? //multiples of 10 would work for rotations
var rotationBlockSize = 10;
var generalizationBlockSize = blockSize;
//some useful values to give all images; 24 for training, 120 for rotation, 24 for testing
var critPercentage = .5; //make sure that this value is a whole proportion of the block size, for each category
var blockCriterion = Math.floor(blockSize/2*critPercentage); //Criterion to move. How many correct responses per category within a block
var blockTrial = 0;
var blocksCompleted = 0; //to keep track of blocks in each phase
var blocksRequired = 2; //to end a given phase, only used if requireCriterion is false
var trialsInBlock = getBlock(trainSet, blockSize);
var trialExemplar;
var trialCategory;
var trialRotation;
var requireCriterion = false;  
var block_finished = false;
var training_finished = false;
var rotation_finished = false;
var generalization_finished = false;
//console.log([blockSize, critPercentage, blockCriterion]);


/* text for the instruction check questions */
var Q0_text = "<b>Question 1:</b> What will you be doing during this task?";
var Q0_answers = ["I will complete a questionnaire about my personality.", "On each trial I will see a circle, and will be asked what color it is.", "On each trial I will see three pictures, and will decide which of two side pictures is correct, based on the picture located on the center of the screen."];     // Last one is correct
var Q1_text = "<b>Question 2:</b> How often will you receive feedback on your decisions?";
var Q1_answers = ["Never", "After every trial", "After every 10 trials"];     // Second one is correct
var Q2_text = "<b>Question 3:</b> How can I receive a bonus of $"+bonusAmount+"?";
var Q2_answers = ["I will receive a bonus if I make more correct responses than the average participant.", "I will receive a bonus if more than half of my responses are correct.", "I cannot receive a bonus."];     // Last one is correct
var correctstring = '{"Q0":"' + Q0_answers[2] + '","Q1":"' + Q1_answers[1] + '","Q2":"' + Q2_answers[0]+ '"}';


var choiceTrial = {
    type: 'html-keyboard-response',
	prompt: button_prompt,
    choices: ['F', 'J'],
	stimulus: function(){
		var exemplar_img;
		if (expPhase == 'Training' | expPhase == 'Generalization'){
			exemplar_img = trainSet[trialsInBlock[blockTrial]].exemplar;
		}else{
			exemplar_img = rotSets[trialsInBlock[blockTrial][0]][trialsInBlock[blockTrial][1]].exemplar;
		}
		html = '<img src="'+image_root+exemplar_img+'">'
		console.log(html)
		return html;
	},
    on_finish: function(trial_data) {
		if (expPhase == 'Rotation'){
			h = rotSets[trialsInBlock[blockTrial][0]][trialsInBlock[blockTrial][1]]
		}else{
			h = trainSet[trialsInBlock[blockTrial]];
		}
		trialExemplar = h.exemplar;
		trialCategory = h.category;
		trialRotation = h.rotation;
		if (evalChoice(trial_data.key_press, trialCategory, catKey)) {
			correctionTrial = false;
			trialOutcome = 1;
		}else{
			trialOutcome = 0;
			correctionTrial = true;
		}
		if (firstAttempt){
			firstAttempt = false;
			if (trialCategory == 'CA'){
				blockCACorrects = blockCACorrects+trialOutcome;
			}else{
				blockNMCorrects = blockNMCorrects+trialOutcome;
			}
			//save data
			jsPsych.data.addDataToLastTrial({
				trial: totalTrials,
				correct: trialOutcome,
				exemplar: trialExemplar,
				category: trialCategory,
				rotation: trialRotation,
				phase: expPhase
			});
		}
		console.log([blockCACorrects, blockNMCorrects, blockSize])
		if (!correctionTrial){
			totalTrials++;
			blockTrial++;
		}
	}
};

var trialFeedback = {
	type:'html-keyboard-response',
    choices: jsPsych.NO_KEYS,
	trial_duration: feedbackDuration,
	stimulus: function(){
		if (correctionTrial){
				return '<b>Error!</b>'
			}else{
				return '<b>Correct!</b>'
		}
	}
}

var blockScreen = {
	type: 'html-keyboard-response',
	stimulus: function(){
				console.log([blockCACorrects, blockNMCorrects, blockSize])
				return 'You have completed a block of training!<br><br>Your accuracy during the last block was: '+Math.round((blockCACorrects+blockNMCorrects)/blockSize*100)+'%. <br><br> You can take a break now, if you choose to do so. <br><br><b>Press any key to continue with the experiment.</b>'
			},
	on_start: function(){
		if (expPhase == 'Rotation'){
			getBlocksFromArray(rotSets, blockSize);
		}else{
			trialsInBlock = getBlock(trainSet, blockSize);
		}
	},
	on_finish: function(){
			blockTrial = 0
			blockCACorrects = 0;
			blockNMCorrects = 0;
		}
}

function blockChecker(){
	block_finished = false
		if (!correctionTrial & blockTrial > 0 & !((blockTrial)%blockSize)){
			block_finished = true
			blocksCompleted++;
		}
	return block_finished
}


var blockCheck = {
	type: 'html-keyboard-response',
	timeline: [blockScreen],
	conditional_function: blockChecker
}

var trainingTrialLoop = {
    timeline: [choiceTrial, trialFeedback],
	loop_function: function() {
		if (!correctionTrial){
			firstAttempt = true;
		}
        return correctionTrial;
    }
};

var trainingBlockLoop = {
	timeline: [trainingTrialLoop, blockCheck],
	loop_function: function(){
		return !block_finished
	}
}

var endOfTrainingScreen = {
	type: 'html-keyboard-response',
	stimulus: function(){
			return 'END OF TRAINING'
		},
	on_finish: function(){
		expPhase = 'Rotation';
		blocksCompleted = 0;
		blockSize = rotationBlockSize;
		trialsInBlock = getBlocksFromArray(rotSets, blockSize);
	}
}

var trainCheck = {
	timeline: [endOfTrainingScreen],
	conditional_function: function(){
		if (requireCriterion){
			console.log('training criterion check')
			if ((blockCACorrects >= blockCriterion) & (blockNMCorrects >= blockCriterion)){
				console.log('passed')
				training_finished = true;
			}
		}else{
			console.log('training blocks check')
			if (blocksCompleted >= blocksRequired){
				training_finished = true;
			}
		}
		return training_finished
	}
}

var trainLoop = {
	timeline: [trainingBlockLoop, trainCheck],
	loop_function: function(){
		return !training_finished
		}
}

var endOfRotationScreen = {
	type: 'html-keyboard-response',
	stimulus: function(){
			return 'END OF ROTATION'
		},
	on_finish: function(){
		expPhase = 'Generalization';
		blocksCompleted = 0;
		blockSize = generalizationBlockSize;
		trialsInBlock = getBlock(novelSet, blockSize);
	}
}

var rotationCheck = {
	timeline: [endOfRotationScreen],
	conditional_function: function(){
		if (requireCriterion){
			console.log('rotation criterion check')
			if ((blockCACorrects >= blockCriterion) & (blockNMCorrects >= blockCriterion)){
				console.log('passed')
				rotation_finished = true;
			}
		}else{
			console.log('rotation blocks check')
			if (blocksCompleted >= blocksRequired){
				rotation_finished = true;
			}
		}
		return rotation_finished
	}
}


var rotationLoop = {
	timeline: [trainingBlockLoop, rotationCheck],
	loop_function: function(){
		return !rotation_finished
		}
}

///WE'RE CODING OVER HERE


var probeTrial = {
    type: 'html-keyboard-response',
	prompt: button_prompt,
    choices: ['F', 'J'],
	stimulus: function(){
		var exemplar_img = novelSet[trialsInBlock[blockTrial]].exemplar;
		html = '<img src="'+image_root+exemplar_img+'">'
		console.log(html)
		return html;
	},
    on_finish: function(trial_data) {
		h = novelSet[trialsInBlock[blockTrial]];
		trialExemplar = h.exemplar;
		trialCategory = h.category;
		trialRotation = h.rotation;
		correctionTrial = false;
		if (evalChoice(trial_data.key_press, trialCategory, catKey)) {
			trialOutcome = 1;
		}else{
			trialOutcome = 0;
		}
		//save data
		jsPsych.data.addDataToLastTrial({
			trial: totalTrials,
			correct: trialOutcome,
			exemplar: trialExemplar,
			category: trialCategory,
			rotation: trialRotation,
			phase: expPhase
		});
		totalTrials++;
		blockTrial++;
	}
};

var generalizationFeedback = {
	type:'html-keyboard-response',
    choices: jsPsych.NO_KEYS,
	trial_duration: feedbackDuration,
	stimulus: function(){
		return '<b>Correct!</b>'
	}
}

var generalizationTrialLoop = {
    timeline: [probeTrial, generalizationFeedback]
};

var generalizationBlockScreen = {
	type: 'html-keyboard-response',
	stimulus: function(){
				return 'You have completed a block of testing!<br><br><b>Press any key to continue with the experiment.</b>'
			},
	on_start: function(){
		trialsInBlock = getBlock(novelSet, blockSize);
	},
	on_finish: function(){
			blockTrial = 0
		}
}

var generalizationBlockCheck = {
	type: 'html-keyboard-response',
	timeline: [generalizationBlockScreen],
	conditional_function: blockChecker
}

var generalizationBlockLoop = {
	timeline: [generalizationTrialLoop, generalizationBlockCheck],
	loop_function: function(){
		return !block_finished
	}
}

var endOfGeneralizationScreen = {
	type: 'html-keyboard-response',
	stimulus: function(){
			return 'END OF GENERALIZATION'
		}
}

var generalizationCheck = {
	timeline: [endOfGeneralizationScreen],
	conditional_function: function(){
		console.log('generalization blocks check')
		console.log([blocksCompleted, blocksRequired])
		if (blocksCompleted >= blocksRequired){
			console.log([blocksCompleted, blocksRequired])
			generalization_finished = true;
		}
		return generalization_finished
	}
}

var generalizationLoop = {
	timeline: [generalizationBlockLoop, generalizationCheck],
	loop_function: function(){
		return !generalization_finished
		}
}

function getTurkCode(){
	//randomize length
	codeLength = jsPsych.randomization.shuffle([6, 7, 8, 9, 10])[0]
	turkcode = (Math.floor(Math.random() * Math.pow(10, codeLength))).toString();
	return turkcode
};






// ******************* BORING STUFF - INSTRUCTIONS, CONSENT FORMS ETC ******************


var initial_instructions = {
    type: "instructions",
    pages: [
        '<p>Thanks for agreeing to take part in this study!</p>In this study, you will be asked to complete a learning task.</p>',
		'<p>On each screen, you will be shown a picture.<br><br>\
		Then, the picture will disappear, and two additional pictures will appear.<br><br>\
		Your task is to decide which one of the two pictures (left or right) is the correct picture, \
		based on the picture that appeared in the center of the screen.<br><br><b>If you think the picture on the left is correct, you should press the F key.<br><br>If you think the picture on the right is correct, you should press the J key.</b><br><br>You will receive feedback for your choice on every trial</p>',
        '<p>Your aim should be to make as many correct responses as you can. <b>You can receive a bonus payment, depending on how many correct responses you make.</b><br><br>We will collect data from a large number of participants in this task, and calculate the average number of correct responses that they made.<br><br><b>If you make more correct responses than the average participant, you will receive a bonus of $'+bonusAmount+'. So the more correct responses you make, the more likely you are to receive a bonus.</b></p>',
        '<p>There will be ' + numTrialsTotal + ' trials in total. You can take as long as you like on each trial (your reaction time is not important in this study), but we recommend that you don\'t spend too long on any one trial. Typically, this experiment will take around 25-30 minutes to complete.<br><br><strong>Please don\'t write anything down during the experiment.</strong></p>'
    ],
    show_clickable_nav: true,
    timing_post_trial: 100
};

var repeatInstructions = true;

var ready_to_start = {
    type: "html-button-response",
    stimulus: "<p><br><center><b>Well done - all your answers were correct!</b></center><br></p>",
    is_html: true,
    choices: ['<p>Click here to start the experiment</p>'],
    button_html: '<button class="fancyButton" style="vertical-align:middle"><span>%choice%</span></button><br><br>',
    timing_post_trial: 500
};

var instruction_check = {
    type: "survey-multi-choice",
    preamble: ["<p align='center'><b>Check your knowledge before you begin!</b></p>"],
    questions: [{prompt: Q0_text, name: 'Q0', options: Q0_answers, required: true}, 
				{prompt: Q1_text, name: 'Q1', options: Q1_answers, required: true},
				{prompt: Q2_text, name: 'Q2', options: Q2_answers, required: true}],
    timing_post_trial: 100,
    on_finish: function(data) {
        if( data.responses == correctstring) {
            repeatInstructions = false;
        }
    }
};

var check_failed_display = {
    type: "html-button-response",
    stimulus: '<p><br><center><b>Unfortunately, at least one of your answers was incorrect.</b></center><br></p>',
    is_html: true,
    choices: ['<p>Click here to read the instructions again</p>'],
    timing_post_trial: 300
};


var check_failed_conditional = {
    timeline: [check_failed_display],
    conditional_function: function(){
        return repeatInstructions;      // If this is true, it will execute timeline (show failure screen)
    }
};

var loop_instructions = {
    timeline: [initial_instructions, instruction_check, check_failed_conditional],
    loop_function: function() {
        return repeatInstructions;  // If repeatInstructions remains true, this will keep looping; if it becomes false, it will move on.
    }
};

//Function to log only the important data and avoid a request that is too large for datastore
function getTrialData(dat){
	dat = dat.ignore(['internal_node_id', 'stimulus', 'trial_type', 'trial_index', 'time_elapsed'])
	return dat.filterCustom(function(trial){
		return trial.key_press != null | trial.responses != null
	})
}


var expt_finished_questions = {
    type: "survey-text",
    preamble: function() {
        return "<p>The task is finished - well done!</p><b><p>Overall you made " + Math.round(100 * totalCorrect/totalTrials) + "% correct responses</p></b><p>Before we tell you a bit more about what we were studying in this experiment, we have a few quick questions - you can type your answers into the boxes below.</p>";
    },
    questions: [{prompt: "What do you think determined which of the buttons was correct?", rows: 5, columns: 60},
				{prompt: "Were you distracted while you completed the task? e.g., by using your phone etc.", rows: 5, columns: 60},
				{prompt: "Do you have any general comments about the experiment?", rows: 5, columns: 60}],
    timing_post_trial: 100,

    on_finish: function() {
        $.post('submit',{"content": getTrialData(jsPsych.data.get()).csv()}); // uncomment to post data
		//getTrialData(jsPsych.data.get()).localSave('csv', 'turkdata.csv')
      }
};

var debrief = {
    type: "html-button-response",
    stimulus: '<p>Thanks for taking part in this experiment! We appreciate your participation.<br><br>\
	In this study, we are investigating:<br><br>\
	(1) How people learn using feedback.<br><br>\
	(2) How people combine different types of information (what they know is correct and what they know is incorrect) when they make decisions.<br><br></p>',
    is_html: true,
    choices: ['<b>Please click here to receive your completion code</b>'],
    timing_post_trial: 100
};

var turkCode = {
type: "html-keyboard-response",
    stimulus: 'All done!<br><br>Your completion code is <b> ' + turkcode + '</b><br><br>To receive payment for the HIT, return to the Amazon Mechanical Turk page and enter this code.<br><br>Please contact us if something goes wrong and we will fix it as quickly as possible.</p>',
    is_html: true,
    timing_post_trial: 100,
	choices: jsPsych.NO_KEYS
	}




// ******************* SET TIMELINE AND RUN EXPT ******************

var exptTimeline = [];
//exptTimeline.push(loop_instructions);
//exptTimeline.push(ready_to_start);
exptTimeline.push(trainLoop);
exptTimeline.push(rotationLoop);
exptTimeline.push(generalizationLoop);
exptTimeline.push(expt_finished_questions);
exptTimeline.push(debrief);
exptTimeline.push(turkCode);




/* function to start the jsPsych experiment */
function startExperiment(){

    // record the turkcode in the jsPsych data
    jsPsych.data.addProperties({
        workerID: turkWorkerID,
        rSeed: rSeed,
        turkcode: turkcode
    });

    jsPsych.init({
        timeline: exptTimeline
    });
};


/* start by running the "welcome" */
//welcome.run();
startExperiment();

</script>

</html>
